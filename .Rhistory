renv::init()
install.packages("tidyverse")
install.packages("torch")
library(dplyr)
library(purrr)
library(tidyr)
library(torch)
window = 5
weights <- torch_ones(window, requires_grad = FALSE)/window
weights
weights$shape
weights <- torch_zeros(window, requires_grad = FALSE)
weights
weights[0:required_pad] = 1
required_pad = 1
weights[0:required_pad] = 1
weights
weights[1:required_pad] = 1
weights
weights[(window-required_pad):window] <- 1
weights
weights <- torch_zeros(window, requires_grad = FALSE)
weights[1:required_pad] <- 1
weights[(window-required_pad + 1):window] <- 1
weights
weights = weights/sum(weights)
weights
weights$shape[1]
weights$shape
weights = weights$view(1,1,weights$shape[1])
weights <- torch_zeros(window, requires_grad = FALSE)
weights[1:required_pad] <- 1
weights[(window-required_pad + 1):window] <- 1
weights <- weights/sum(weights)
weights <- weights$view(1,1,weights$shape)
weights <- torch_zeros(window, requires_grad = FALSE)
weights[1:required_pad] <- 1
weights[(window-required_pad + 1):window] <- 1
weights <- weights/sum(weights)
weights <- torch_ones(window, requires_grad = FALSE)/window
weights <- weights$view(1,1,weights$shape)
weights <- weights$view(c(1,1,weights$shape))
weights
weights$shape
weights <- torch_zeros(window, requires_grad = FALSE)
weights[1:required_pad] <- 1
weights[(window-required_pad + 1):window] <- 1
weights <- weights/sum(weights)
weights <- weights$view(c(1,1,weights$shape))
weights
?torch_tensor
data <- c(0,0,1,1,1,0,0,1,1,1,1,1)
data <- torch_tensor(data)
data <- data$view(c(1,1,length(data)))
data
weights <- .generate_weights(window, continuous, required_pad)
.generate_weights <- function(window, continuous, required_pad) {
if (continuous) {
weights <- torch_ones(window, requires_grad = FALSE)/window
weights <- weights$view(c(1,1,weights$shape))
} else {
weights <- torch_zeros(window, requires_grad = FALSE)
weights[1:required_pad] <- 1
weights[(window-required_pad + 1):window] <- 1
weights <- weights/sum(weights)
weights <- weights$view(c(1,1,weights$shape))
}
}
weights <- .generate_weights(window, continuous, required_pad)
continuous = TRUE
weights <- .generate_weights(window, continuous, required_pad)
outputs <- .forward(data, weights, window)
.forward <- function(data, weights, window) {
accessible_times <- torch_zeros(window, data$shape[3])
}
outputs <- .forward(data, weights, window)
outputs
.forward <- function(data, weights, window) {
accessible_times <- torch_zeros(c(window, data$shape[3]))
}
outputs <- .forward(data, weights, window)
outputs
data$shape
data$shape[3]
window
x <- data
start = 1
x_ = x[, , start:x$shape[3]]
x_
start = 3
x_ = x[, , start:x$shape[3]]
x_
start <- 1
x_ <- x[, , start:x$shape[3]]
x1 <- torch_conv1d(x_, weights, stride = window)
x1
accessible_times <- torch_zeros(c(window, x$shape[3]), requires_grad = FALSE)
x_ <- x[, , start:x$shape[3]]
x1 <- torch_conv1d(x_, weights, stride = window)
x1$shape
x_$shape
x1 <- torch_conv1d(input = x_, weight = weights, stride = window)
x1
x_ <- x[, , start:x$shape[3]]
x1 <- nnf_conv1d(input = x_, weight = weights, stride = window)
x1
# pad the result with 0
x1 <- nnf_pad(input = x1, pad = c(0, x$shape[3] - x1$shape[3]), mode = 'constant', value = 0)
x1
x1$shape
x_ <- x[, , start:x$shape[3]]
x1 <- nnf_conv1d(input = x_, weight = weights, stride = window)
# pad the result with 0
x1 <- nnf_pad(input = x1, pad = c(1, x$shape[3] - x1$shape[3]), mode = 'constant', value = 0)
x1
x_ <- x[, , start:x$shape[3]]
x1 <- nnf_conv1d(input = x_, weight = weights, stride = window)
# pad the result with 0
x1 <- nnf_pad(input = x1, pad = c(0, x$shape[3] - x1$shape[3]), mode = 'constant', value = 0)
x1 <- x1$floor_()
x1
accessible_times <- torch_zeros(c(window, x$shape[3]), requires_grad = FALSE)
for (start in 1:window){
x_ <- x[, , start:x$shape[3]]
x1 <- nnf_conv1d(input = x_, weight = weights, stride = window)
# pad the result with 0
x1 <- nnf_pad(input = x1, pad = c(0, x$shape[3] - x1$shape[3]), mode = 'constant', value = 0)
x1 <- x1$floor_()
accessible_times[start, ] <- x1$squeeze_()
}
accessible_times
daata
data
dat <- accessible_times
dat
idx <- torch_nonzero(torch_transpose(dat,0,1), as_tuple=True)
idx <- torch_nonzero(torch_transpose(dat,0,1))
idx <- torch_nonzero(torch_transpose(dat,1,2))
idx
rows <- idx[2]
dat
dat$shape
?torch_nonzero
idx <- torch_nonzero(torch_transpose(dat,1,2), as_tuple = TRUE)
idx <- torch_nonzero(dat, as_tuple = TRUE)
idx <- torch_nonzero(dat)
idx
dat[idx]
rows <- idx[2]
idx[1]
idx[1][1]
idx[2]
idx <- torch_nonzero(dat)
rows <- idx[1][2]
cols <- idx[1][1]
rows
cols
idx <- torch_nonzero(torch_transpose(dat, 1, 2))
rows <- idx[1][2]
cols <- idx[1][1]
rows
dat
rows <- idx[1][2] + 1
cols <- idx[1][1] + 1
rows
cols
pos <- cols*self.ww + rows
pos <- cols*window + rows
pos
data
data
dat
rows <- idx[1][2]
cols <- idx[1][1]
pos <- cols*window + rows
pos
pos <- cols*window + rows + 1
pos
data <- c(0,1,0,1,1,1,1,1,1,1,1,1,1)
data <- torch_tensor(data)
data <- data$view(c(1,1,length(data)))
weights <- .generate_weights(window, continuous, required_pad)
outputs <- .forward(data, weights, window)
.forward <- function(x, weights, window) {
accessible_times <- torch_zeros(c(window, x$shape[3]), requires_grad = FALSE)
for (start in 1:window){
x_ <- x[, , start:x$shape[3]]
x1 <- nnf_conv1d(input = x_, weight = weights, stride = window)
# pad the result with 0
x1 <- nnf_pad(input = x1, pad = c(0, x$shape[3] - x1$shape[3]), mode = 'constant', value = 0)
x1 <- x1$floor_()
accessible_times[start, ] <- x1$squeeze_()
}
return(accessible_times)
}
outputs <- .forward(data, weights, window)
outputs
dat <- outputs
idx <- torch_nonzero(torch_transpose(dat, 1, 2))
rows <- idx[1][2]
cols <- idx[1][1]
pos <- cols*window + rows + 1
pos
idx
idx$shape
idx[1]
idx <- torch_nonzero(torch_transpose(dat, 1, 2))
pos <- sapply(idx, function(k){
rows <- idx[2]
cols <- idx[1]
cols*window + rows + 1
})
seq_along(idx)
idx <- torch_nonzero(torch_transpose(dat, 1, 2))
pos <- sapply(1:idx$shape[1], function(k){
rows <- idx[k][2]
cols <- idx[k][1]
cols*window + rows + 1
})
pos
y <- idx$detach()
y$cpu()
y <- y$cpu()
y$numel()
y$numpy_T()
idx <- torch_nonzero(torch_transpose(dat, 1, 2))
pos <- sapply(1:idx$shape[1], function(k){
rows <- idx[k][2]
cols <- idx[k][1]
out <- cols*window + rows + 1
out <- unlist(out)
})
pos
as.vector(pos[[1]])
pos[[1]]$data()
# convert to vector
vec_mask <- seq(1, length(pos))
vec_mask
# convert to vector
vec_mask <- rep(1, length(pos))
vec_mask
pos[[1]]$numpy_T()
pos[[1]]$numpy()
idx <- torch_nonzero(torch_transpose(dat, 1, 2))
pos <- sapply(1:idx$shape[1], function(k){
rows <- idx[k][2]
cols <- idx[k][1]
out <- as_array(cols*window + rows + 1)
})
pos
a_pos <- .accessible_pos(f_pass, window, rm_overlap)
#' function to generate the weight vector
#' for the convolution step
.generate_weights <- function(window, continuous, required_pad) {
if (continuous) {
weights <- torch_ones(window, requires_grad = FALSE)/window
weights <- weights$view(c(1,1,weights$shape))
} else {
weights <- torch_zeros(window, requires_grad = FALSE)
weights[1:required_pad] <- 1
weights[(window-required_pad + 1):window] <- 1
weights <- weights/sum(weights)
weights <- weights$view(c(1,1,weights$shape))
}
}
#' forward pass to perform convolution
.forward <- function(x, weights, window) {
accessible_times <- torch_zeros(c(window, x$shape[3]), requires_grad = FALSE)
for (start in 1:window){
x_ <- x[, , start:x$shape[3]]
x1 <- nnf_conv1d(input = x_, weight = weights, stride = window)
# pad the result with 0
x1 <- nnf_pad(input = x1, pad = c(0, x$shape[3] - x1$shape[3]), mode = 'constant', value = 0)
x1 <- x1$floor_()
accessible_times[start, ] <- x1$squeeze_()
}
return(accessible_times)
}
#' find nonzero pos in the results of the conv
.accessible_pos <- function(dat, window, rm_overlap) {
idx <- torch_nonzero(torch_transpose(dat, 1, 2))
pos <- sapply(1:idx$shape[1], function(k){
rows <- idx[k][2]
cols <- idx[k][1]
out <- as_array(cols*window + rows + 1)
})
}
data <- torch_tensor(data)
data
weights <- .generate_weights(window, continuous, required_pad)
f_pass <- .forward(data, weights, window)
a_pos <- .accessible_pos(f_pass, window, rm_overlap)
outputs <- torch_zeros(data$shape[3])
outputs[a_pos] <- 1
outputs
outputs <- as_array(outputs)
outputs
length(outputs)
data$shape[3]
source('~/MyApps/sequenceR/R/accessibility.R')
x <- c(0,0,0,1,1,1,1,1,1,0,0,0,1,1,1)
find_sequences(x, window = 3)
x
find_sequences(x, window = 3)
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
library(sequenceR)
roxygen2::roxygenise()
library(sequenceR)
library(sequenceR)
x <- c(0,0,0,1,1,1,1,1,0,0,1,1,1)
find_sequences(x, window = 3)
library(sequenceR)
x <- c(0,0,0,1,1,1,1,1,0,0,1,1,1)
find_sequences(x, window = 3)
library(sequenceR)
find_sequences(x, window = 3)
library(sequenceR)
find_sequences(x, window = 3)
source('~/MyApps/sequenceR/R/suggest_packages.R')
library(sequenceR)
source('~/MyApps/sequenceR/R/suggest_packages.R')
library(sequenceR)
roxygen2::roxygenise()
roxygen2::roxygenise()
library(sequenceR)
find_sequences(x, window = 3)
x <- runif(10000)
x <- ifelse(x < 0.5, 0, 1)
y <- find_sequences(x, window = 3)
x <- runif(100000)
y <- find_sequences(x, window = 3)
x
x <- ifelse(x < 0.5, 0, 1)
y <- find_sequences(x, window = 3)
x <- c(0,0,0,1,1,1,1,1,0,0,1,1,1)
data <- x
window = 3
continuous = TRUE
required_pad = 1
rm_overlap = FALSE
data <- torch::torch_tensor(data)
data <- data$view(c(1,1,length(data)))
weights <- .generate_weights(window, continuous, required_pad)
f_pass <- .forward(data, weights, window)
#' function to generate the weight vector
#' for the convolution step
.generate_weights <- function(window, continuous, required_pad) {
if (continuous) {
weights <- torch::torch_ones(window, requires_grad = FALSE)/window
weights <- weights$view(c(1,1,weights$shape))
} else {
weights <- torch::torch_zeros(window, requires_grad = FALSE)
weights[1:required_pad] <- 1
weights[(window-required_pad + 1):window] <- 1
weights <- weights/sum(weights)
weights <- weights$view(c(1,1,weights$shape))
}
}
#' forward pass to perform convolution
.forward <- function(x, weights, window) {
accessible_times <- torch::torch_zeros(c(window, x$shape[3]), requires_grad = FALSE)
for (start in 1:window){
x_ <- x[, , start:x$shape[3]]
x1 <- torch::nnf_conv1d(input = x_, weight = weights, stride = window)
# pad the result with 0
x1 <- torch::nnf_pad(input = x1, pad = c(0, x$shape[3] - x1$shape[3]), mode = 'constant', value = 0)
x1 <- x1$floor_()
accessible_times[start, ] <- x1$squeeze_()
}
return(accessible_times)
}
weights <- .generate_weights(window, continuous, required_pad)
f_pass <- .forward(data, weights, window)
a_pos <- .accessible_pos(f_pass, window, rm_overlap)
dat <- f_pass
idx <- torch::torch_nonzero(
torch::torch_transpose(dat, 1, 2)
)
idx
idx[1]
idx$shape
p <- 1:idx$shape[1]
p
idx[p][1]*window + idx[p][2] + 1
pos <- sapply(1:idx$shape[1], function(k){
rows <- idx[k][2]
cols <- idx[k][1]
out <- torch::as_array(cols*window + rows + 1)
})
pos
idx[p]
idx <- torch::as_array(idx)
idx
idx[,1]*window + idx[,2] + 1
idx <- torch::torch_nonzero(
torch::torch_transpose(dat, 1, 2)
)
idx <- torch::as_array(idx)
pos <- idx[,1]*window + idx[,2] + 1
roxygen2::roxygenise()
library(sequenceR)
x <- runif(100000)
x <- ifelse(x < 0.5, 0, 1)
y <- find_sequences(x, window = 3)
y
x[1:30]
x <- runif(1000000)
x <- ifelse(x < 0.5, 0, 1)
y <- find_sequences(x, window = 3)
x <- runif(10000000)
y <- find_sequences(x, window = 3)
x <- runif(10000000)
x <- ifelse(x < 0.5, 0, 1)
y <- find_sequences(x, window = 3)
x <- runif(1000000000)
x <- runif(100000000)
x <- ifelse(x < 0.5, 0, 1)
y <- find_sequences(x, window = 3)
x <- runif(100000000)
x <- ifelse(x < 0.5, 0, 1)
y <- find_sequences(x, window = 3)
